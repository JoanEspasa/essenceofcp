\section{Introduction}

This text is aimed at people with a bit of experience in programming. Maybe you
remeber your mathematics class  who has heard the term

\subsection{What is Constraint Programming}

The majority of programming languages were designed with the imperative paradigm
in mind. In these languages, statements describe how the program state changes.
The work of the programmer is to devise which sequences of statements produce the
desired result.

In contrast, Constraint Programming (CP) is a declarative paradigm. Now instead
of focusing on \emph{how}, the programmer should focus on stating \emph{what} the program
should accomplish. If we were to situate CP in the map, it would be a picturesque 
isle between the seas of artificial intelligence, computer science and
operations research.

Constraint Programming states relations between variables in the form of
constraints, specifying the properties of the solution. These constraints can
take many forms, such as logical ($\neg$,$\vee$ or $\wedge$) or numerical (+,
-, $*$) operators for example.

The set of constraints is then solved by giving a value to each variable so
that the solution is consistent with the stated constraints.  Do not worry, we
will give more formal and complete definitions further in the book, but for now it
should suffice.

\subsection{Modeling}

In our setting, a model is a description of a problem using the concepts that the
language supports.

\subsection{And Essence?}
