\section{Introduction}

Most probably, during your career as a programmer you have found
a seemingly simple problem that, when it increased a bit in size, you could not
get a solution for it in a reasonable amount of time. All the ideas and approaches
you had for it seemed useless and you wondered why.

And if you still have not, I guarantee that at some point you will.
% because they are everywhere!
This text aims to make you a more effective and knowledgeable programmer,
by providing a new and shiny tool to confront them. But first at all, lets give 
these problems a name.

\subsection{Combinatorial Problems}

A \emph{combinatorial problem} consists in finding, among a finite set of
objects, one that satisfies a set of constraints. With Constraint Programming
you will be able to solve many kinds of combinatorial problems. 

Amongst combinatorial problems, the ones we are specially interested in are the
ones for which exhaustive search is not tractable. For solving these problems
we will need to identify the patterns or regularities in them and exploit these
in a clever way; to make deductions and decisions until we make our way into a
solution that satisfies all the constraints. All of this without introducing any
bug and considering all edge cases.

And as a programmer, you know that the effort in doing all of the above is not
small. Luckly for us we are not the first ones to confront these problems.

%\subsection{Imperative vs Declarative}
\subsection{What is Constraint Programming?}

The majority of programming languages were designed with the imperative
paradigm in mind. In these languages, statements describe how the program state
changes.  The work of the programmer is to devise which sequences of statements
produce the desired result. In other words, an imperative program is trying to
explain the ``how to'' to a computer.

\begin{example}
If we are given a value $x$ and we are asked to find it's square root, we might
apply the Babylonian method: (i) start with a guess $g$ (ii) improve the
guess $g$ by averaging $g$ and $x/g$ (iii) keep improving the guess $g$
until it is good enough.
%
The basic idea is that if $g$ is an overestimate to the square root of $x$,
then $x/g$ will be an underestimate. So, the average of these two numbers will
provide a better approximation.
\end{example}

In contrast, Constraint Programming (CP) is a declarative paradigm. This means
that instead of focusing on \emph{how}, the programmer should focus on describing
\emph{what} the program should accomplish. 
%In other words, it should describe ``what is true''.

\begin{example}
In a declarative paradigm, to find the square root of $x$ it is enough to 
state: $\sqrt{x}$ is the $y$ such that $y^2 = x$ and $y \geq 0$.
%
Note that this statement tells you what the square root is without having to
describe how you should find the square root. 
\end{example}

The beauty of this paradigm is that it will allow us to translate a problem
statement into a solvable problem specification \emph{without} having to come
up with an imperative algorithm. 

%If we were to situate Constraint Programming in a map, it would be
%a picturesque isle between the seas of artificial intelligence, computer
%science and operations research.

More generally, constraint Programming states relations between problem
variables in the form of constraints, specifying the properties of the
solution. These constraints can take many forms, such as logical ($\neg$,$\vee$
or $\wedge$) or numerical (+, -, $*$) operators for example.
%
The set of constraints is then automatically solved by giving a value to each
variable so that the solution is consistent with the stated constraints.  Do
not worry, we will give more formal and complete definitions in the future, but
for now this should suffice.

\subsection{Modelling}

In our setting, a \emph{model} is a translation from the description of a
combinatorial problem into a computable formulation. Models are typically
expressed in terms of constraints that can be understood by an application
called a \emph{solver}. With a model, the solver will perform analysis, 
inference and search on it. This process will end in solutions to the model that
can then be interpreted in terms of the original description of the problem. 

% TODO: Diagram for showing the process


%                     model                            solve         
% find sqrt(x=16) plz ----->  find g such that g*g = x ---->  g = 4 
%
%


\subsection{Essence Prime and Savile Row}

Savile Row is a modelling assistant for Constraint Programming. It provides a
high-level language for the user to specify their constraint problem, and
automatically translates that language to the input language of a constraint
solver. It is a flexible tool, so it is very easy to add new rules and new
translation pipelines.

Savile Row takes in the Essence Prime constraint modelling language. Essence
Prime is intended to be a declarative, solver-independent and high-level language. 

Savile Row is named after a street in London with many bespoke tailors. The
name comes from the idea of ``tailoring'' a constraint model in a variety of
different ways.


Savile Row supports various solvers and solver types.
CP
SAT
SMT

